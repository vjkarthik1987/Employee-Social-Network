<% layout('layouts/_layout') %>

<section style="max-width:900px;margin:24px auto;">
  <!-- Post card -->
  <div class="card" style="margin-bottom:1rem;">
    <div class="card-header" style="display:flex;justify-content:space-between;">
      <div>
        <strong><%= post.authorId?.fullName || 'User' %></strong>
        <small>
          ‚Ä¢ <%= new Date(post.createdAt || post.publishedAt).toLocaleString() %>
          <% if (post.type) { %> ‚Ä¢ <span class="badge"><%= post.type %></span><% } %>
          <% if (post.group && post.group._id) { %>
            ‚Ä¢ in <a href="/<%= company.slug %>/g/<%= post.group._id %>"><%= post.group.name %></a>
          <% } %>
        </small>
      </div>

      

      <% if (user && (String(user._id) === String(post.authorId?._id || post.authorId) || ['ORG_ADMIN','MODERATOR'].includes(user.role))) { %>
        <form method="POST" action="/<%= company.slug %>/posts/<%= post._id %>/delete" onsubmit="return confirm('Delete this post?')">
          <input type="hidden" name="_csrf" value="<%= typeof csrfToken !== 'undefined' ? csrfToken : '' %>">
          <button class="btn btn-ghost" type="submit">Delete</button>
        </form>
      <% } %>
    </div>

    <div class="post-metrics" style="margin:.5rem 0; color:#666; display:flex; gap:1rem; flex-wrap:wrap; font-size:.95rem; margin-bottom: 20px;">
      <span>üëÅ <%= post.viewsCount || 0 %> views</span>
      <span>üéâ <%= post.totalReactions || 0 %> reactions</span>
      <span>üí¨ <%= post.commentsCount || 0 %> comments</span>
      <span>‚ÜóÔ∏è <%= post.engagementRate || 0 %>% engagement</span>
      <% if (typeof viewed !== 'undefined' && viewed) { %>
        <span style="opacity:.6;">üëÅ Viewed</span>
      <% } %>
    </div>

    <!-- Reactions (single source of truth for counts + buttons) -->
    <%- include('../partials/_post_card', { company, user, post, compact: false }) %>
  </div>

  <!-- Comments -->
  <section class="comments-area" style="margin-top:18px;">
    <h3 class="ca-title">Comments</h3>
  
    <% if (user) { %>
      <!-- Top-level composer -->
      <form method="POST"
            action="/<%= company.slug %>/api/posts/<%= post._id %>/comments"
            class="cc-composer"
            id="new-comment-form">
        <input type="hidden" name="_csrf" value="<%= typeof csrfToken !== 'undefined' ? csrfToken : '' %>">
        <div class="cc-row">
          <img class="cc-avatar" src="<%= user?.avatarUrl || '/img/avatar.png' %>" alt="">
          <div class="cc-inputwrap">
            <textarea name="content" class="cc-input" rows="1" placeholder="Write a comment‚Ä¶" maxlength="3000" required enterkeyhint="send"></textarea>

            <div class="cc-tools">
              <button type="button" class="cc-emoji-btn" title="Add emoji" aria-label="Add emoji">üôÇ</button>
              <span class="cc-count" data-cc-count>0/3000</span>
              <button class="cc-send" type="submit" disabled aria-label="Post comment">‚û§</button>
            </div>
          </div>
        </div>
      </form>
    <% } %>
  
    <ul id="comments-list" class="cc-list">
      <% (comments || []).forEach(function(c){ %>
        <%- include('../partials/_comment', { company, user, post, comment: c, replies: [], repliesByParent: {} }) %>
      <% }) %>
    </ul>
  </section>
  
</section>

<!-- Reactions JS (PUT /:org/api/reactions) -->
<script>
(function(){
  const ORG = "<%= company.slug %>";

  document.addEventListener('click', async (e) => {
    const btn = e.target.closest('[data-react]');
    if (!btn) return;

    const bar = btn.closest('[data-react-scope]');
    if (!bar) return;

    const type = btn.getAttribute('data-react');              // e.g. LIKE
    const targetType = bar.getAttribute('data-target-type');  // 'post'
    const targetId = bar.getAttribute('data-target-id');

    const resp = await fetch(`/${ORG}/api/reactions`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
      body: JSON.stringify({ targetType, targetId, reactionType: type })
    });
    const data = await resp.json();
    if (!data.ok) { alert('Could not react.'); return; }

    const spans = {
      LIKE:       bar.querySelector('[data-rc="LIKE"]'),
      HEART:      bar.querySelector('[data-rc="HEART"]'),
      CELEBRATE:  bar.querySelector('[data-rc="CELEBRATE"]'),
      SUPPORT:    bar.querySelector('[data-rc="SUPPORT"]'),
      LAUGH:      bar.querySelector('[data-rc="LAUGH"]'),
      INSIGHTFUL: bar.querySelector('[data-rc="INSIGHTFUL"]'),
      THANKS:     bar.querySelector('[data-rc="THANKS"]')
    };
    const bump = (el, d) => { if (!el) return; el.textContent = Math.max(0, (parseInt(el.textContent||'0',10) + d)); };

    if (data.added) {
      bump(spans[data.added], +1);
      bar.querySelectorAll('[data-react].active')?.forEach(b => b.classList.remove('active'));
      const newBtn = bar.querySelector(`[data-react="${data.added}"]`);
      if (newBtn) newBtn.classList.add('active');
    }

    if (data.removed) {
      bump(spans[data.removed], -1);
      bar.querySelectorAll('[data-react].active')?.forEach(b => b.classList.remove('active'));
    }

    if (data.changedTo) {
      if (data.prevType && data.prevType !== data.changedTo) {
        bump(spans[data.prevType], -1);
      }
      bump(spans[data.changedTo], +1);
      bar.querySelectorAll('[data-react].active')?.forEach(b => b.classList.remove('active'));
      const newBtn = bar.querySelector(`[data-react="${data.changedTo}"]`);
      if (newBtn) newBtn.classList.add('active');
    }

    const totalEl = bar.querySelector('[data-total-reactions]');
    if (totalEl) {
      const sum = Array.from(bar.querySelectorAll('.rc')).reduce((n, s) => n + parseInt(s.textContent||'0',10), 0);
      totalEl.textContent = String(sum);
    }
  });
})();
</script>

<!-- Comments JS (top-level + replies + delete via AJAX) -->
<script>
(function(){
  const org = "<%= company.slug %>";
  const postId = "<%= post._id %>";
  const commentsCountEl = document.getElementById('comments-count'); // present inside _reactions_bar totals
  const list = document.getElementById('comments-list');

  function bumpCommentsCount(delta){
    if (!commentsCountEl) return;
    const n = parseInt(commentsCountEl.textContent || '0', 10) + (delta || 0);
    commentsCountEl.textContent = Math.max(0, n);
  }

  // Submit top-level comment (AJAX)
  const newForm = document.getElementById('new-comment-form');
  if (newForm) {
    newForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      const body = new URLSearchParams(new FormData(newForm));

      const resp = await fetch(newForm.action, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'Accept': 'application/json'
        },
        body
      });
      const data = await resp.json();
      if (!data.ok) return alert('Could not add comment.');
      const temp = document.createElement('div');
      temp.innerHTML = data.html.trim();
      const li = temp.firstElementChild;
      if (li) list.appendChild(li);
      bumpCommentsCount(data.commentsCountDelta || 0);
      newForm.reset();
    });
  }

  // Delegate: Reply toggle + Delete (comment/reply)
  document.addEventListener('click', async (e) => {
    const t = e.target;

    if (t.matches('[data-reply-toggle]')) {
      e.preventDefault();
      const id = t.getAttribute('data-reply-toggle');
      const el = document.getElementById('reply-form-' + id);
      if (el) el.style.display = (el.style.display === 'none' || !el.style.display) ? 'block' : 'none';
      return;
    }

    if (t.matches('[data-ajax-delete]')) {
      e.preventDefault();
      const commentId = t.getAttribute('data-comment-id');
      if (!commentId) return;
      if (!confirm('Delete this comment?')) return;
      const url = `/${org}/api/comments/${commentId}`;
      const resp = await fetch(url, { method: 'DELETE', headers: { 'Accept': 'application/json' } });
      const data = await resp.json();
      if (!data.ok) return alert('Delete failed');

      const selector = data.isReply ? `[data-reply-id="${data.commentId}"]`
                                    : `[data-comment-id="${data.commentId}"]`;
      const node = document.querySelector(selector);
      if (node) {
        const content = node.querySelector('.comment-content');
        if (content) content.innerHTML = '<em style="color:#888;">(deleted)</em>';
        const delBtn = node.querySelector('[data-ajax-delete]'); if (delBtn) delBtn.remove();
      }
      bumpCommentsCount(data.commentsCountDelta || 0);
    }
  });

  // Delegate: reply form submit (has data-ajax-reply)
  document.addEventListener('submit', async (e) => {
    const f = e.target;
    if (!f.matches('[data-ajax-reply]')) return;
    e.preventDefault();
    const fd = new FormData(f);
    const resp = await fetch(f.action, { method: 'POST', body: fd, headers: { 'Accept': 'application/json' } });
    const data = await resp.json();
    if (!data.ok) return alert('Could not add reply.');
    const parentId = data.parentCommentId;
    const container = document.querySelector(`[data-comment-id="${parentId}"] [data-replies]`);
    if (container) {
      container.style.display = 'block';
      const temp = document.createElement('div');
      temp.innerHTML = data.html.trim();
      const li = temp.firstElementChild;
      if (li) container.appendChild(li);
    }
    bumpCommentsCount(data.commentsCountDelta || 0);
    f.reset();
    f.style.display = 'none';
  });
})();
</script>
<script>
  (function(){
    // auto-resize, counters, enable/disable send, ctrl+enter
    // function bindComposer(root){
    //   const ta = root.querySelector('.cc-input');
    //   const count = root.querySelector('[data-cc-count]');
    //   const send = root.querySelector('.send-btn');
    //   if (!ta) return;
  
    //   const max = parseInt(ta.getAttribute('maxlength') || '3000', 10);
  
    //   const autosize = () => {
    //     ta.style.height = 'auto';
    //     ta.style.height = Math.min(ta.scrollHeight, 160) + 'px';
    //   };
  
    //   const updateUI = () => {
    //     const val = ta.value.trim();
    //     if (count) count.textContent = `${ta.value.length}/${max}`;
    //     if (send) send.disabled = !val.length;
    //   };
  
    //   ta.addEventListener('input', () => { autosize(); updateUI(); });
    //   ta.addEventListener('keydown', (e) => {
    //     // Ignore IME composition (important for Indian languages, etc.)
    //     if (e.isComposing) return;

    //     // Shift+Enter ‚Üí newline (let it through)
    //     if (e.key === 'Enter' && e.shiftKey) return;

    //     // Plain Enter ‚Üí submit (no Ctrl/Meta)
    //     if (e.key === 'Enter' && !e.ctrlKey && !e.metaKey && !e.altKey) {
    //       e.preventDefault(); // stop newline
    //       const form = ta.closest('form');
    //       const sendBtn = form?.querySelector('.cc-send');
    //       if (form && sendBtn && !sendBtn.disabled) {
    //         // Triggers your existing submit listeners (AJAX)
    //         form.requestSubmit();
    //       }
    //     }
    //   });

  
    //   // initial
    //   autosize(); updateUI();
    // }
  
    // bind top-level composer
    const topForm = document.getElementById('new-comment-form');
    if (topForm) bindComposer(topForm);
  
    // bind any visible reply composers on load
    document.querySelectorAll('.reply-form').forEach(bindComposer);
  
    // when a reply form is toggled to visible, (re)bind it
    document.addEventListener('click', (e) => {
      const t = e.target.closest('[data-reply-toggle]');
      if (!t) return;
      const id = t.getAttribute('data-reply-toggle');
      const form = document.getElementById('reply-form-' + id);
      if (!form) return;
      setTimeout(() => bindComposer(form), 0);
    });
  
    // after AJAX insert of a freshly rendered comment/reply, ensure any nested composer is bound if present
    document.addEventListener('cc:bind', (e) => {
      if (e.target) bindComposer(e.target);
    });
  })();
  </script>

<script>
  (function(){
    // === scoped to comments-area ===
    const root = document.querySelector('.comments-area');
    if (!root) return;
  
    function bindComposer(form){
      const ta = form.querySelector('.cc-input');
      const cnt = form.querySelector('[data-cc-count]');
      const send = form.querySelector('.cc-send');
      const emojiBtn = form.querySelector('.cc-emoji-btn');
      if (!ta) return;
  
      const max = parseInt(ta.getAttribute('maxlength') || '3000', 10);
  
      const autosize = () => { ta.style.height='auto'; ta.style.height = Math.min(ta.scrollHeight,160)+'px'; };
      const refresh  = () => {
        const len = ta.value.length;
        if (cnt) cnt.textContent = `${len}/${max}`;
        if (send) send.disabled = ta.value.trim().length === 0;
      };
  
      ta.addEventListener('input', () => { autosize(); refresh(); });
      ta.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
          if (send && !send.disabled) form.requestSubmit();
        }
      });
  
      // simple emoji insert (placeholder for real picker later)
      if (emojiBtn) {
        emojiBtn.addEventListener('click', () => {
          const emoji = 'üôÇ';
          const start = ta.selectionStart ?? ta.value.length;
          const end   = ta.selectionEnd ?? ta.value.length;
          ta.value = ta.value.slice(0, start) + emoji + ta.value.slice(end);
          ta.focus();
          ta.selectionStart = ta.selectionEnd = start + emoji.length;
          autosize(); refresh();
        });
      }
  
      // init
      autosize(); refresh();
    }
  
    // bind top composer
    const topForm = document.getElementById('new-comment-form');
    if (topForm) bindComposer(topForm);
  
    // bind visible reply composers now
    root.querySelectorAll('.cc-reply').forEach(bindComposer);
  
    // when a reply form is toggled open, bind it
    document.addEventListener('click', (e) => {
      const t = e.target.closest('[data-reply-toggle]');
      if (!t) return;
      const id = t.getAttribute('data-reply-toggle');
      const form = document.getElementById('reply-form-' + id);
      if (form) setTimeout(() => bindComposer(form), 0);
    });
  
    // (Optional) if you AJAX-insert new composers later, dispatch this to bind:
    // node.dispatchEvent(new CustomEvent('cc:bind', { bubbles:true }));
    document.addEventListener('cc:bind', (e) => {
      const form = e.target.closest('.cc-composer, .cc-reply');
      if (form) bindComposer(form);
    });

    ta.addEventListener('keydown', (e) => {
    // Ignore while IME is composing characters
    if (e.isComposing) return;

    // Submit on Enter
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();  // stop newline
      const form = ta.closest('form');
      const sendBtn = form?.querySelector('.cc-send');
      if (form && sendBtn && !sendBtn.disabled) {
        form.requestSubmit();
      }
      return;
    }

    // Allow Shift+Enter to insert a newline
  });


    
  })();
  </script>
  
  